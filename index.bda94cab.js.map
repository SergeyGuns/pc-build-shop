{"mappings":"ACAE,CAAA,cAKoB,EAJlB,IAOQ,EAPJ,EAAW,IACT,EAAM,SAAS,aAAa,CAAC,aACnC,GAAI,AAAQ,OAAR,EAAc,OAClB,IAAM,EAAM,EAAI,UAAU,CAAC,MAyBvB,EAAS,EAAE,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,aAAa,CAAC,mBAAmB,gBAAgB,CAAC,OAAQ,AAAC,GAAK,EAAG,GAAG,EACpG,EAAiB,EACjB,EAAQ,EACN,GA3BY,EA2Ba,KAC3B,sBAAsB,KAClB,IAAM,EAAO,EAAI,qBAAqB,GAItC,GAFA,AADA,CAAA,aAAe,SAAS,EAAK,MAAM,CAAI,CAAA,OAAO,WAAW,CAAG,GAAA,EAAO,IAAnE,EACe,IAAO,CAAA,aAAe,EAAA,EACrC,aAAe,GAAM,CAAA,aAAe,CAAA,EACjC,IAAa,aAAc,OAC9B,EAAW,aACX,IAAM,EAAW,KAAK,KAAK,CAAC,EAAO,MAAM,CAAG,IAAM,GAClD,EAAiB,EACjB,CAAA,EAAQ,CAAA,EACI,GAAI,CAAA,EAAQ,CAAA,CAC5B,EAAE,EApCE,EAAQ,KAKL,SAAiB,GAAG,CAAI,EAC7B,iDAAiD;AACjD,2CAA2C;AACvC,GAEJ,qDAAqD;AACrD,CAAA,EAAQ,WAAW,KACjB,qDAAqD;AACrD,KAAU,GAEV,+BAA+B;AAC/B,aAAa,GACb,EAAQ,IACV,EAkBG,IAlBH,CACF,GAmBJ,SAAS,gBAAgB,CAAC,SAAU,GAKpC,IAAM,EAAe,MAAM,QAAQ,GAAG,CAAC,EAAO,GAAG,CAAC,AAAA,GACvC,IAAI,QAAQ,AAAA,IACf,IAAM,EAAM,IAAI,MAChB,EAAI,gBAAgB,CAAC,OAAO,KACxB,EAAQ,EACZ,EAAE,CAAA,GACF,EAAI,GAAG,CAAG,CACd,KACA,IAAI,CAAC,AAAA,GACE,EAAO,GAAG,CAAC,AAAA,IACd,IAAM,EAAM,SAAS,aAAa,CAAC,SACnC,CAAA,EAAI,KAAK,CAAG,KACZ,EAAI,MAAM,CAAG,KACb,IAAM,EAAM,EAAI,UAAU,CAAC,MAC3B,EAAI,SAAS,CAAC,EAAI,EAAE,GACpB,IAAM,EAAU,EAAI,YAAY,CAAC,EAAG,EAAG,KAAM,MACvC,EAAO,EAAQ,IAAI,CACzB,IAAK,IAAI,EAAI,EAAG,EAAI,EAAK,MAAM,CAAE,GAAK,EAAG,CACrC,IAAM,EAAM,CAAI,CAAC,EAAE,CACb,EAAQ,CAAI,CAAC,EAAI,EAAE,CACnB,EAAO,CAAI,CAAC,EAAI,EAAE,AACV,CAAA,CAAI,CAAC,EAAI,EAAE,CAErB,EAAM,KAAO,EAAQ,KAAO,EAAO,MACrC,CAAI,CAAC,EAAE,CAAG,EACV,CAAI,CAAC,EAAI,EAAE,CAAG,EACd,CAAI,CAAC,EAAI,EAAE,CAAG,EACd,CAAI,CAAC,EAAI,EAAE,CAAG,GAEZ,EAAM,KAAO,EAAQ,KAAO,EAAO,MACnC,CAAI,CAAC,EAAE,CAAG,EACV,CAAI,CAAC,EAAI,EAAE,CAAG,EACd,CAAI,CAAC,EAAI,EAAE,CAAG,EACd,CAAI,CAAC,EAAI,EAAE,CAAG,GAEpB,CACA,IAAI,EAAM,IAAI,MAChB,OAAO,CACX,KAQJ,AALA,SAAS,IACL,EAAI,YAAY,CAAC,CAAY,CAAC,EAAe,CAAE,EAAG,GAClD,EAAI,KAAK,CAAC,SAAS,CAAG,CAAC,MAAM,EAAE,EAAM,CAAC,CAAC,CACvC,OAAO,qBAAqB,CAAC,EACjC,GAEJ,CAAA,G,4D","sources":["<anon>","src/js/corousel.js"],"sourcesContent":["(async ()=>{\n    let xPercent = 100;\n    const cnv = document.querySelector(\".corousel\");\n    if (cnv === null) return;\n    const ctx = cnv.getContext(\"2d\");\n    const throttle = (callee, timeout)=>{\n        // Таймер будет определять,\n        // надо ли нам пропускать текущий вызов.\n        let timer = null;\n        // Как результат возвращаем другую функцию.\n        // Это нужно, чтобы мы могли не менять другие части кода,\n        // чуть позже мы увидим, как это помогает.\n        return function perform(...args) {\n            // Если таймер есть, то функция уже была вызвана,\n            // и значит новый вызов следует пропустить.\n            if (timer) return;\n            // Если таймера нет, значит мы можем вызвать функцию:\n            timer = setTimeout(()=>{\n                // Аргументы передаём неизменными в функцию-аргумент:\n                callee(...args);\n                // По окончании очищаем таймер:\n                clearTimeout(timer);\n                timer = null;\n            }, timeout);\n        };\n    };\n    let images = [].map.call(document.querySelector(\".preload-images\").querySelectorAll(\"img\"), (el)=>el.src);\n    let drawImageIndex = 0;\n    let scale = 1;\n    const throttledDraw = throttle(()=>{\n        requestAnimationFrame(()=>{\n            const rect = cnv.getBoundingClientRect();\n            xPercentCurr = parseInt(rect.bottom / (window.innerHeight + 400) * 100);\n            xPercentCurr > 99 && (xPercentCurr = 99);\n            xPercentCurr < 0 && (xPercentCurr = 0);\n            if (xPercent === xPercentCurr) return;\n            xPercent = xPercentCurr;\n            const currDraw = Math.floor(images.length / 100 * xPercent);\n            drawImageIndex = currDraw;\n            scale = 1;\n            if (scale < 1) scale = 1;\n        });\n    }, 100);\n    document.addEventListener(\"scroll\", throttledDraw);\n    const loadedImages = await Promise.all(images.map((url)=>{\n        return new Promise((resolve)=>{\n            const img = new Image();\n            img.addEventListener(\"load\", ()=>{\n                resolve(img);\n            }, false);\n            img.src = url;\n        });\n    })).then((images)=>{\n        return images.map((img)=>{\n            const cnv = document.createElement(\"canvas\");\n            cnv.width = 1920;\n            cnv.height = 1038;\n            const ctx = cnv.getContext(\"2d\");\n            ctx.drawImage(img, 0, 0);\n            const imgData = ctx.getImageData(0, 0, 1920, 1038);\n            const data = imgData.data;\n            for(let i = 0; i < data.length; i += 4){\n                const red = data[i];\n                const green = data[i + 1];\n                const blue = data[i + 2];\n                const alpha = data[i + 3];\n                if (red > 240 && green > 240 && blue > 240) {\n                    data[i] = 0;\n                    data[i + 1] = 0;\n                    data[i + 2] = 0;\n                    data[i + 3] = 1;\n                }\n                if (red > 200 && green > 200 && blue > 200) {\n                    data[i] = 0;\n                    data[i + 1] = 0;\n                    data[i + 2] = 0;\n                    data[i + 3] = 0.5;\n                }\n            }\n            var img = new Image;\n            return imgData;\n        });\n    });\n    function loop() {\n        ctx.putImageData(loadedImages[drawImageIndex], 0, 0);\n        cnv.style.transform = `scale(${scale})`;\n        window.requestAnimationFrame(loop);\n    }\n    loop();\n})();\n\n//# sourceMappingURL=index.bda94cab.js.map\n",";(async ()=>{\r\n    let xPercent = 100;\r\n    const cnv = document.querySelector('.corousel')\r\n    if (cnv === null) return;\r\n    const ctx = cnv.getContext('2d')\r\n    const throttle = (callee, timeout) => {\r\n        // Таймер будет определять,\r\n        // надо ли нам пропускать текущий вызов.\r\n        let timer = null\r\n      \r\n        // Как результат возвращаем другую функцию.\r\n        // Это нужно, чтобы мы могли не менять другие части кода,\r\n        // чуть позже мы увидим, как это помогает.\r\n        return function perform(...args) {\r\n          // Если таймер есть, то функция уже была вызвана,\r\n          // и значит новый вызов следует пропустить.\r\n          if (timer) return\r\n      \r\n          // Если таймера нет, значит мы можем вызвать функцию:\r\n          timer = setTimeout(() => {\r\n            // Аргументы передаём неизменными в функцию-аргумент:\r\n            callee(...args)\r\n      \r\n            // По окончании очищаем таймер:\r\n            clearTimeout(timer)\r\n            timer = null\r\n          }, timeout)\r\n        }\r\n    }\r\n    let images = [].map.call(document.querySelector('.preload-images').querySelectorAll('img'), (el)=>el.src);\r\n    let drawImageIndex = 0;\r\n    let scale = 1;\r\n    const throttledDraw = throttle(()=> {\r\n        requestAnimationFrame(()=>{\r\n            const rect = cnv.getBoundingClientRect(); \r\n            xPercentCurr = parseInt(rect.bottom / (window.innerHeight + 400) * 100);\r\n            xPercentCurr > 99 && (xPercentCurr = 99);\r\n            xPercentCurr < 0 && (xPercentCurr = 0);\r\n            if(xPercent === xPercentCurr) return;\r\n            xPercent = xPercentCurr\r\n            const currDraw = Math.floor(images.length / 100 * xPercent)\r\n            drawImageIndex = currDraw\r\n            scale = 1\r\n            if( scale < 1){ scale = 1}\r\n        })}, 100)\r\n\r\n    document.addEventListener('scroll', throttledDraw);\r\n    \r\n    \r\n    \r\n    \r\n    const loadedImages = await Promise.all(images.map(url=> {\r\n        return new Promise(resolve => {\r\n            const img = new Image(); \r\n            img.addEventListener(\"load\",()=>{\r\n                resolve(img)\r\n            },false,);\r\n            img.src = url;\r\n        })\r\n    })).then(images => {\r\n        return images.map(img => {\r\n            const cnv = document.createElement('canvas')\r\n            cnv.width = 1920;\r\n            cnv.height = 1038;\r\n            const ctx = cnv.getContext('2d')\r\n            ctx.drawImage(img,0,0)\r\n            const imgData = ctx.getImageData(0, 0, 1920, 1038)\r\n            const data = imgData.data\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                const red = data[i];\r\n                const green = data[i + 1];\r\n                const blue = data[i + 2];\r\n                const alpha = data[i + 3];\r\n              \r\n                if (red > 240 && green > 240 && blue > 240) {\r\n                  data[i] = 0;\r\n                  data[i + 1] = 0;\r\n                  data[i + 2] = 0;\r\n                  data[i + 3] = 1\r\n                }\r\n                if (red > 200 && green > 200 && blue > 200) {\r\n                    data[i] = 0;\r\n                    data[i + 1] = 0;\r\n                    data[i + 2] = 0;\r\n                    data[i + 3] = 0.5\r\n                  }\r\n              }\r\n              var img = new Image;\r\n            return imgData\r\n        })\r\n    })\r\n\r\n    function loop () {\r\n        ctx.putImageData(loadedImages[drawImageIndex], 0, 0)\r\n        cnv.style.transform = `scale(${scale})`\r\n        window.requestAnimationFrame(loop);\r\n    }\r\n    loop()\r\n})();;"],"names":["callee","timer","xPercent","cnv","document","querySelector","ctx","getContext","images","map","call","querySelectorAll","el","src","drawImageIndex","scale","throttledDraw","requestAnimationFrame","rect","getBoundingClientRect","xPercentCurr","parseInt","bottom","window","innerHeight","currDraw","Math","floor","length","args","setTimeout","clearTimeout","addEventListener","loadedImages","Promise","all","url","resolve","img","Image","then","createElement","width","height","drawImage","imgData","getImageData","data","i","red","green","blue","loop","putImageData","style","transform"],"version":3,"file":"index.bda94cab.js.map"}